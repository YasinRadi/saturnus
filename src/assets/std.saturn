/*
    Saturnus Standard Library
*/

// Runtime
fn panic(message) {
  <extern "Lua">
    error(message);
  </extern>
}

// Collections and iterators
fn entries(tbl) {
  <extern "Lua">
    local iter = pairs(tbl);
    return function(_, next)
      local k, v = iter(tbl, next and next._0);
      if k ~= nil and v ~= nil then
        return { _0 = k, _1 = v }, v;
      end
    end;
  </extern>
}

let private = {};

class Vector {
  fn new(data) {
    return Vector { [private]: { data } };
  }
  fn at(self, key) {
    return self[private].data[key + 1];
  }
  fn set(self, key, value) {
    self[private].data[key] = value;
  }
  fn pop(self) {
    if self.len() > 0 {
      let value = self[private].data[#? self[private].data];
      self[private].data[#? self[private].data] = ();
      return value;
    }
    return ();
  }
  fn push(self, value) {
    self[private].data[#? self[private].data + 1] = value;
  }
  fn len(self) {
    return #? self[private].data;
  }
  fn iter(self) {
    return entries(self[private].data);
  }
}

class Object {
  fn entries(target) {
    return entries(target);
  }
}

class Tuple {
  fn new(data) {
    return Vector { [private]: { data } };
  }
  fn at(self, key) {
    return self[private].data[key];
  }
  fn set(self, key, value) {
    self[private].data[key] = value;
  }
  fn len(self) {
    return #? self[private].data;
  }
  fn iter(self) {
    return entries(self[private].data);
  }
}

// File system name space.
class fs {
  fn read_file(path) {
    <extern "Lua">
      do
        local f = io.open(path, 'r');
        local data = f:read('*all');
        f:close();
        return data;
      end
    </extern>
    panic("File system's read file supported for this platform!");
  }
  fn write_file(path, content) {
    <extern "Lua">
      do
        local f = io.open(path, 'w');
        f:write(content);
        f:close();
        return;
      end
    </extern>
    panic("File system's write file supported for this platform!");
  }
}

// The RTTI module
class rtti {
  fn arguments(*args) {
    return (target, name) => {
      // TODO: Implement arguments typecheck decorator.
    };
  }
}

class math {
  fn max(a, b) {
    <extern "Lua">
    do
      return math.max(a, b);
    end
    </extern>
    panic("Math.max not supported on this platform!");
  }
  fn min(a, b) {
    <extern "Lua">
    do
      return math.min(a, b);
    end
    </extern>
    panic("Math.min not supported on this platform!");
  }
  fn abs(a) {
    <extern "Lua">
    do
      return math.abs(a);
    end
    </extern>
    panic("Math.abs not supported on this platform!");
  }
  fn ceil(a) {
    <extern "Lua">
    do
      return math.ceil(a);
    end
    </extern>
    panic("Math.max not supported on this platform!");
  }
  fn floor(a) {
    <extern "Lua">
    do
      return math.floor(a);
    end
    </extern>
    panic("Math.floor not supported on this platform!");
  }
}

// OOP and inheritance
let makeTrait = (name) => () => panic("Trait " ++ name ++ " is not constructible!");

fn trait() {
  return (target, name) => {
    target.__meta__.__call = makeTrait(name);
  };
}

fn impl(trait) {
  return (target, name) => {
    let map = {};
    for (k, v) in entries(target.prototype) {
      map[k] = v;
    }
    for (k, v) in entries(trait.prototype) {
      if map[k] == () {
        panic(name ++ " must implement trait method " ++ k ++ "!");
      }
    }
  };
}

fn mixin(parent) {
  let index = parent.prototype.__meta__.__index;
  if type(index) == "table" {
    index = (self, key) => parent.prototype.__meta__.__index[key];
  }
  return (target, name) => {
    let prev = target.prototype.__meta__.__index;
    if type(prev) == "table" {
      let prev_tbl = prev;
      prev = (self, key) => prev_tbl[key];
    }
    target.prototype.__meta__.__index = (self, key) => {
      return prev(self, key) or index(self, key);
    };
  };
}

let makePure = (name) => () => panic("Attempting to call abstract method " ++ name ++ "!");

fn abstract() {
  return (_, name, host, label, meta) => {
    if meta.is_static {
      host[name] = makePure(label ++ "::" ++ name);
    } else {
      host.prototype[name] = makePure(label ++ "." ++ name);
    }
  };
}

// STD Custom operators
fn `|>`(left, right) {
  return right(left);
}

fn `<|`(left, right) {
  return left(right);
}

fn `::`(arr, elem) {
  <extern "Lua">
    do
      table.insert(arr, elem);
      return arr;
    end
  </extern>
  panic("Operator :: not supported on this platform");
}

fn `:::`(left, right) {
  <extern "Lua">
    local u = table.unpack or unpack;
    local tbl = { u(left) };
    for _, v in pairs(right) do
      tbl[#tbl + 1] = v;
    end
    return tbl;
  </extern>
}

fn `+?`(left, right) {
  return left and (left + right);
}
fn `+??`(left, right) {
  return left and (left + right) or right;
}

fn `++?`(left, right) {
  return left and (left ++ right);
}
fn `++??`(left, right) {
  return left and (left ++ right) or right;
}

fn `-?`(left, right) {
  return left and (left - right);
}
fn `-??`(left, right) {
  return left and (left - right) or right;
}

fn `*?`(left, right) {
  return left and (left * right);
}
fn `*??`(left, right) {
  return left and (left * right) or right;
}

fn `/?`(left, right) {
  return left and (left / right);
}
fn `/??`(left, right) {
  return left and (left / right) or right;
}

fn `..`(start, _end) {
  let i = start;
  if start < _end {
    return () => {
      if i > _end {
        return ();
      }
      let c = i;
      i += 1;
      return c;
    };
  } else {
    return () => {
      if i < _end {
        return ();
      }
      let c = i;
      i -= 1;
      return c;
    };
  }
}

return {
  Object,
  Tuple,
  Vector,
  range,
  abstract,
  trait,
  impl,
  mixin,
  panic,
  entries,
  fs,
  rtti,
  math,
  `:::`, `..`, `|>`, `<|`, `+?`, `+??`, `++?`, `++??`, `-?`, `-??`, `*?`, `*??`,
  `/?`, `/??`, `::`
};
